<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>并发 Concurrency</title>
</head>

<body>

    <div class="reveal">
        <div class="slides">

            <section class="title-slide">
                <div class="huge framed bordered border-3x font-passionone bg-warning-alpha-08">
                    并发 Concurrency
                </div>
            </section>
            <section>
                <div class="down-30 center">
                    The world is concurrent.</div>
                <div class="down-3 right">
                    -- Joe Armstrong
                </div>
            </section>

            <section>
                <div class="down-30 right">
                    "空间是并存事物的次序，或是同时发生的所有事物存在的次序"
                </div>
                <div class="down-3 right">
                    -- Leibniz
                </div>
            </section>

            <section>
                <div class="down-30 center larger">
                    概念篇 </div>
            </section>


            <section>
                <div class="down-3">
                    <h2>进程 vs. 线程</h2>
                </div>
                <div class="down-9">
                    <ul>
                        <li>
                            进程：是系统进行资源分配和调度的一个独立单位，也是一个具有独立功能的程序；

                        </li>
                        <li>
                            线程：线程依托于进程而存在,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位。
                            线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),
                            但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。
                        </li>
                    </ul>
                </div>
                <div class="down-3">
                    区别在于
                    <ul>
                        <li>
                            进程属于资源分配的单位，而线程则是作业调度的单位
                        </li>
                        <li>
                            进程拥有自己的地址空间，而多个线程拥有自己的堆栈和局部变量，并共享所依托于进程的资源。
                        </li>
                    </ul>
                </div>

            </section>

            <section>
                <div class="down-3">
                    <h2>多进程、多线程</h2>
                </div>
                <div class="down-9">
                    <div class="down-1 ">
                        多进程操作的意义在于多个计算任务轮流共享CPU的时间片(针对单处理器情形，多处理器可理解为并行)并发执行。
                    </div>
                    <div class="down-1 ">
                        每个计算任务（进程）内又可以存在多个线程（指令执行序列）。
                    </div>
                </div>
            </section>

            <section>

                <div class="down-3">
                    <h2>并发 vs. 并行</h2>
                </div>
                <div class="down-1 center">
                    <div class="center down-1">
                        <img
                            src="http://images.cnitblog.com/blog/94031/201307/01001508-e1a4c7ed78274ec4aa325b928af044e5.png" />
                    </div>
            </section>

            <section>
                <div class="down-3">
                    <h2>多线程优势</h2>
                </div>
                <div class="down-9">
                    <div class="down-1 ">
                        多线程的并发操作优势在于，当程序的某个任务因外部条件问题，导致阻塞，如果没有并发，则整个程序停止，直到外部条件发生变化，使用并发后，程序中的其他任务还可以继续执行。
                        <div class="down-1 ">
                            如果没有阻塞，在单处理器上考虑多线程并发也就没有意义了，线程之间的切换会造成大量的时间消耗。
                        </div>
                    </div>
            </section>

            <section>
                    <div class="down-3">
                        <h2>JVM Threads</h2>
                    </div>
                    <div class="down-5 center">
                        <div class="center down-1">
                            <img
                                src="https://equinoxrar.files.wordpress.com/2014/08/threads1.png" />
                        </div>
                </section>


                <section>
                    <div class="down-30 center larger">
                        基础篇 </div>
                </section>



            <section>
                <div class="down-3">
                    <h2>Runnable接口定义“任务”</h2>
                </div>
                <div class="down-1">
                    <pre class="java tiny">
                        <code data-trim>
                            ublic class LiftOff implements Runnable {
                                protected int countDown = 10; // Default
                                private static int taskCount = 0;
                                private final int id = taskCount++;
                            
                                public LiftOff() {
                                }
                            
                                public LiftOff(int countDown) {
                                    this.countDown = countDown;
                                }
                            
                                public String status() {
                                    return "#" + id + "(" +
                                            (countDown > 0 ? countDown : "Liftoff!") + "), ";
                                }
                            
                                public void run() {
                                    while (countDown-- > 0) {
                                        System.out.print(status());
                                        Thread.yield(); //后面解释
                                    }
                                }
                            }
                            
                            public class MainThread {
                                public static void main(String[] args) {
                                    LiftOff launch = new LiftOff();
                                    launch.run();
                                }
                            }
                        </code>
                        
                    </pre>
                </div>
            </section>

            <section>
                <div class="down-3">
                    <h2>Thread</h2>
                </div>
                <div class="down-5">
                    <code> java.lang.Thread</code>

                </div>
                <div class="down-3">
                    <pre class="java">
                            <code data-trim>
                                public class BasicThreads {
                                    public static void main(String[] args) {
                                        //把任务装进线程里
                                        Thread t = new Thread(new LiftOff());
                                        t.start();
                                        System.out.println("Waiting for LiftOff");
                                    }
                                }
                            </code>
                            
                        </pre>
                </div>
            <div class="down-1">Thread对象像是运载火箭，Runnable的实现对象就是一个荷载（payload）</div>
            </section>

            <section>
                <div class="down-3">
                    <h2>或者</h2>
                </div>
                <div class="down-3">
                    <pre class="java tiny">
                        <code data-trim> 
                            public class SimpleThread extends Thread {
                                private int countDown = 5;
                                private static int threadCount = 0;
                            
                                public SimpleThread() {
                                    // Store the thread name:
                                    super(Integer.toString(++threadCount));
                                    start();
                                }
                            
                                public String toString() {
                                    return "#" + getName() + "(" + countDown + "), ";
                                }
                            
                                public void run() {
                                    while (true) {
                                        System.out.print(this);
                                        if (--countDown == 0)
                                            return;
                                    }
                                }
                            
                                public static void main(String[] args) {
                                    for (int i = 0; i &lt; 5; i++)
                                        new SimpleThread();
                                }
                            }
                        </code>
                        
                    </pre>
                </div>
                <div class="down-1 fragment small center">实际上<code>public class Thread implements Runnable</code></div>
            </section>

            <section>
                <div class="down-3">
                    <h2>多线程，走起</h2>
                </div>
                <div class="down-9">
                    <pre class="java">
                                    <code data-trim>
                                        public class MoreBasicThreads {
                                            public static void main(String[] args) {
                                                for (int i = 0; i < 5; i++)
                                                    new Thread(new LiftOff()).start();
                                                System.out.println("Waiting for LiftOff");
                                            }
                                        }
                                    </code>
                                    
                                </pre>
                </div>

                <div class="down-5 fragment center">
                    直接启动多个<code>Thread</code></div>
            </section>

            <section>
                <div class="down-3">
                    <h2>或者用ExecutorService启动</h2>
                </div>
                <div class="down-9">
                    <pre class="java">
                        <code data-trim>
                            public class CachedThreadPool {
                                public static void main(String[] args) {
                                    ExecutorService exec = Executors.newCachedThreadPool();
                                    for (int i = 0; i < 5; i++)
                                        exec.execute(new LiftOff());
                                    exec.shutdown();
                                }
                            }
                        </code>
                        
                    </pre>
                </div>

                <div class="down-5 fragment danger center"><code>CachedThreadPool</code>根据需要创建新线程的线程池，如果现有线程没有可用的，则创建一个新线程并添加到池中，如果有被使用完但是还没销毁的线程，就复用该线程
                </div>
            </section>
            <section>
                <div class="down-3">
                    <h2>线程池？</h2>
                </div>
                <div class="down-9">
                    <ul>
                        <li>
                                在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。
                        </li>
                        <li>
                                在Java中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。
                        </li>
                        <li>
                                所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁。
                        </li>
                        <li>
                                如何利用已有对象来服务就是一个需要解决的关键问题，其实这就是一些"池化资源"技术产生的原因。
                        </li>
                    </ul>

                </div>
            </section>
            <section>
                <div class="down-3">
                    <h2>说得再明白一点</h2>
                </div>
                <div class="down-9">
                    <pre class="java">
                        <code data-trim>
                                public class Position&lt;T extends Creature&gt;{
                                        private T holder;
                                }
                        </code>
                        
                    </pre>
                </div>

                <div class="down-5 fragment danger center">显式表达Position里是跟某种Creature
                </div>
            </section>

            <section>
                <div class="down-3">
                    <h2> 再定义一个Computer </h2>
                </div>
                <div class="down-3">
                    <pre class="java">
                                        <code data-trim>
                                                public class Computer{

                                                    private HDD mHarddisk;   // 机械硬盘
                                                    
                                                    Computer(HDD harddisk){
                                                        mHarddisk = harddisk;
                                                    }
                                                    
                                                    public Data readDisk(){
                                                        return mHarddisk.read();
                                                    }
                                                    
                                                    public void writeDisk(Data data){
                                                        mHarddisk.write(data);
                                                    }
                                                }
                                        </code>
                                        
                                    </pre>
                </div>

                <div class="down-1 fragment danger center">
                    如果安装的是SSD怎么办？</div>
            </section>
            <section>
                <div class="down-3">
                    <h2> 定义一个SSDComputer？ </h2>
                </div>
                <div class="down-3">
                    <pre class="java">
                                                <code data-trim>
                                                        public class SSDComputer{

                                                            private SSD mHarddisk;   // SSD硬盘
                                                            
                                                            Computer(SSD harddisk){
                                                                mHarddisk = harddisk;
                                                            }
                                                            
                                                            public Data readDisk(){
                                                                return mHarddisk.read();
                                                            }
                                                            
                                                            public void writeDisk(Data data){
                                                                mHarddisk.write(data);
                                                            }
                                                        }
                                                </code>
                                                
                                            </pre>
                </div>

                <div class="down-1 fragment danger center">
                    这当然不好！</div>
            </section>

            <section>
                <div class="down-3">
                    <h2> 抽象一下 </h2>
                </div>
                <div class="down-1">
                    <pre class="java">
                        <code data-trim>
                                public abstract class Disk{};
                                public class SSD extends Disk{};
                                public class HHD extends Disk{};
                                public class Computer{

                                    private Disk disk;   // 抽象的硬盘
                                    
                                    Computer(Disk disk){
                                        this.disk = disk;
                                    }
                                    
                                    public Data readDisk(){
                                        return disk.read();
                                    }
                                    
                                    public void writeDisk(Data data){
                                        disk.write(data);
                                    }
                                }
                        </code>
                                                    
                    </pre>
                </div>

                <div class="down-1 fragment danger center">
                    基于多态实现设计抽象（解耦） </div>
            </section>

            <section>
                <div class="down-3">
                    <h2> 用泛型来做 </h2>
                </div>
                <div class="down-1">
                    <pre class="java">
                        <code data-trim>
                                public class Computer&lt;T extends Disk&gt;{
                                    private T disk;   // 参数类
                                    Computer(T disk){
                                        this.disk = disk;
                                    }
                                    public Data readDisk(){
                                        return disk.read();
                                    }
                                    public void writeDisk(Data data){
                                        disk.write(data);
                                    }
                                    public T getDisk(){
                                        return disk;
                                    }
                                    public void setDisk(T disk){
                                        return this.disk = disk;
                                    }
                                
                                    public static void main(String[] args) {
                                        Computer&lt;SSD&gt; computer = new Computer&lt;SSD&gt;(new SSD());
                                        SSD disk = computer.getDisk(); // No cast needed
                                        //computer.setDisk(new HHD()); // error!
                                    }
                                }
                        </code>
                        
                    </pre>
                </div>
            </section>

            <section>
                <div class="down-3">
                    <h2> 泛型方法 </h2>
                </div>
                <div class="down-9">
                    <pre class="java">
                            <code data-trim>
                                    public class GenericMethods {
                                        public &lt;T&gt; void f(T x) {
                                            System.out.println(x.getClass().getName());
                                        }
                                        public static void main(String[] args) {
                                            GenericMethods gm = new GenericMethods();
                                            gm.f("");
                                            gm.f(1); //autoboxing
                                            gm.f(1.0);
                                            gm.f(1.0F);
                                            gm.f(‘c’);
                                            gm.f(gm);
                                        }
                                    }
                            </code>
                            
                        </pre>
                </div>
            </section>
            <section>
                <div class="down-3">
                    <h2> 再看容器 </h2>
                </div>
                <div class="down-1">
                    <pre class="java">
                                <code data-trim>
                                    public class Holder&lt;T&gt; {
                                            private T obj;
                                            public void set(T obj){
                                                this.obj = obj;
                                            }
                                            public T get(){
                                                return obj;
                                            }
                                            public static void main(String[] args){
                                                Holder&lt;Integer&gt; holder = new Holder&lt;&gt;();
                                                holder.set(1);
                                                //holder.set("Abc"); // error
                                                Integer obj = holder.get(); //无须cast
                                            }       
                                    }
                                </code>
                                                            
                            </pre>
                </div>

                <div class="down-1  large danger center">
                    <span class="fragment"> 多完美！</span> <span class="fragment">
                        可惜这只是编译时刻... 因为运行时的类型信息被擦掉了</span>
                </div>
            </section>

            <section>
                <div class="down-3">
                    <h2> 擦除 </h2>
                </div>
                <div class="down-1">
                    <pre class="java">
                                    <code data-trim>
                                            public class Computer&lt;T extends Disk&gt;{
                                                private T disk;   // 运行时disk是Disk类型
                                                Computer(T disk){
                                                    disk = disk;
                                                }
                                            }
                                    </code>
                                                                
                                </pre>
                </div>

                <div class="down-1  large danger center">
                    <span class="fragment">
                        Java泛型的实现方式就是将类型参数用边界类型替换，在上面的例子中就是把T用Disk替换。这种实现方式看上去就像是把具体的类型（某种硬盘，机械的或者是固态的），擦除到了边界类型（它们的父类Disk)。</span>
                </div>
            </section>

            <section>
                <div class="down-3">
                    <h2>这两个是相同类型么？ </h2>
                </div>
                <div class="down-1">
                    <pre class="java">
                        <code data-trim>
                                ArrayList&lt;Integer&gt; intList = new ArrayList&lt;&gt;();
                                ArrayList rawList = new ArrayList();
                                
                                System.out.println(intList.getClass().getSimpleName());
                                System.out.println(rawList.getClass().getSimpleName());
                        </code>
                                                    
                    </pre>
                </div>


            </section>

            <section>
                <div class="down-3">
                    <h2> 擦除的后果 </h2>
                </div>
                <div class="down-1">
                    <pre class="java">
                            <code data-trim>
                                public class Holder&lt;T&gt; {
                                    private T obj;
                                    public void set(T obj){
                                        this.obj = obj;
                                    }
                                    public T get(){
                                        return obj;
                                    }
                                    public void testT(Object arg){
                                        if (arg instanceof T){ ... } //编译错误
                                        T var = new T(); //编译错误
                                        T[] array = new T[100]; //编译错误
                                        }
                                    }
                                }
                            </code>
                                                        
                        </pre>
                </div>

                <div class="down-1  large danger center">
                    <span class="fragment">
                        这劳什子有何用？！</span>
                </div>
            </section>

            <section>
                <div class="down-3">
                    <h2>T存在的意义</h2>
                </div>
                <div class="down-1">
                    <pre class="java">
                        <code data-trim>
                                public class Holder&lt;T&gt; {
                                    private T obj; //在编译时，该类中的所有的T都会被替换为边界类型Object。
                                    public void set(T obj){
                                        this.obj = obj;
                                    }
                                    public T get(){
                                        return obj;
                                    }
                                    public static void main(String[] args){
                                        Holder&lt;Integer&gt; holder = new Holder&lt;&gt;();
                                        //编译器会检查实参是不是一个Integer，
                                        //虽然这里的1是int类型，但是因为自动包装机制的存在，
                                        //他会被转化为一个Integer，因此能够通过类型检查。
                                        holder.set(1); 
                                        //编译器也会进行类型检查，
                                        //并且自动插入一个Object类型到Integer类型的转型操作。
                                        Integer obj = holder.get();
                                    }       
                                }
                        </code>                     
                    </pre>
                </div>
            </section>
            <section>
                <div class="down-3">
                    <h2>泛型的实际实现</h2>
                </div>
                <div class="down-3">对泛型的处理全部集中在编译期，在编译时，编译器会执行如下操作: </div>
                <div class="down-1">
                    <div class="down-1">
                        <ul>
                            <li class="down-3">
                                会将泛型类的类型参数都用边界类型替换
                            </li>
                            <li class="down-3">
                                对于传入对象给方法形参的指令，编译器会执行一个类型检查，看传入的对象是不是类型参数所指定的类型
                            </li>
                            <li class="down-3">
                                对于返回类型参数表示对象的指令，也会执行一个类型检查，还会插入一个自动的向下转型，将对象从边界类型向下转型到类型参数所表示的类型
                            </li>
                        </ul>
                    </div>
                </div>

            </section>

            <section>
                <div class="down-3">
                    <h2> 所以这些都是错的 </h2>
                </div>
                <div class="down-1">
                    <pre class="java">
                        <code data-trim>
                            public class Holder&lt;T&gt; {
                                private T obj;
                                public void set(T obj){
                                    this.obj = obj;
                                }
                                public T get(){
                                    return obj;
                                }
                                public void testT(Object arg){
                                    if (arg instanceof T){ ... } //编译错误
                                    T var = new T(); //编译错误
                                    T[] array = new T[100]; //编译错误
                                    }
                                }
                            }
                        </code>
                                                    
                    </pre>
                </div>
            </section>

            <section>
                <div class="down-3">
                    <h2>如果真想生成泛型对象？</h2>
                </div>
                <div class="down-1">
                    <pre class="java">
                            <code data-trim>
                                class Holder&lt;T&gt;{
                                    private T t;
                                    public void init(IFactory&lt;T&gt; factory){
                                        this.t = factory.create();  // 此处即为new T()的工厂方法的实现
                                    }
                                }
                                
                                interface IFactory&lt;T&gt;{  //接口也可以参数化
                                    T create();
                                }
                                
                                class IntegerFactory implements IFactory&lt;Integer&gt;{
                                    public Integer create(){
                                        return new Integer(10);
                                    }
                                }
                                
                                public class newTwithFactory{
                                    public static void main(String[] args){
                                        Holder&lt;Integer&gt; holder = new Holder&lt;&gt;();
                                        holder.init(new IntegerFactory());
                                    }
                                }
                            </code>
                                                        
                        </pre>
                </div>
            </section>
            <section>
                <div class="down-3">
                    <h2>或者可以使用RTTI</h2>
                </div>
                <div class="down-1">
                    <pre class="java">
                            <code data-trim>
                                    class Holder&lt;T&gt;{
                                            private T t;
                                            private Class&lt;T&gt; kind;
                                            public Holder(Class&lt;T&gt; kind){
                                                this.kind = kind;
                                            }
                                            public void init(){
                                                try{
                                                    this.t = kind.newInstance();
                                                }catch (Exception e){
                                                    e.printStackTrace();
                                                }
                                            }
                                            public static void main(String[] args) {
                                                Holder&lt;Integer&gt; holder = new Holder&lt;&gt;(Integer.class);
                                                holder.init();
                                            }
                                    }
                            </code>
                                                        
                        </pre>
                </div>
            </section>
            <section>
                <div class="down-3">
                    <h2>边界 Bounds</h2>
                </div>
                <div class="down-3">
                    用<code>extends</code>申明对参数类型的限制条件
                </div>
                <div class="down-1">
                    <pre class="java">
                        <code data-trim>
                                interface HasColor{ java.awt.Color getColor(); }

                                class Colored &lt;T extends HasColor&gt;{...}

                                class Dimension { public int x,y,z; }

                                class ColoredDimension &lt;T extends HasColor & Dimension&gt;{...} //错误！
                                class ColoredDimension &lt;T extends Dimension & HasColor&gt;{
                                    
                                }
                        </code>              
                    </pre>
                </div>
            </section>
            <section>
                <div class="down-3">
                    <h2>看看这个例子</h2>
                </div>

                <div class="down-9">
                    <pre class="java">
                            <code data-trim>
                                class Fruit{}
                                class Apple extends Fruit{}

                                public class NonConvariantGeneric {
                                    List&lt;Fruit&gt; flist = new ArrayList&lt;Apple&gt;(); //编译错误
                                }
                            </code>              
                        </pre>
                </div>
            </section>
            <section>
                <div class="down-3">
                    <h2>再看看这个例子</h2>
                </div>

                <div class="down-1">
                    <pre class="java">
                        <code data-trim>
                            class Fruit {}
                            class Apple extends Fruit {}
                            
                            class Plate&lt;T&gt;{
                                private T item;
                                public Plate(T t){item=t;}
                                public void set(T t){item=t;}
                                public T get(){return item;}
                            }
                            
                            //现在我定义一个“水果盘子”，逻辑上水果盘子当然可以装苹果。
                            //但实际上Java编译器不允许这个操作。会报错，“装苹果的盘子”无法转换成“装水果的盘子”。
                            Plate&lt;Fruit&gt; p=new Plate&lt;Apple&gt;(new Apple()); //编译错误！
                        </code>              
                    </pre>
                </div>
                <div class="down-1  large danger center">
                    <span class="fragment">
                        “苹果” IS-A “水果”</span>
                </div>
                <div class="down-1  large danger center">
                    <span class="fragment">
                        BUT “装苹果的盘子” NOT-IS-A “装水果的盘子”！</span>
                </div>
            </section>

            <section>
                <div class="down-3">
                    <h2>协变与逆变</h2>
                </div>

                <div class="down-9">
                    协变与逆变(Covariance and contravariance )是在计算机科学中，描述具有父/子型别关系的多个型别通过型别构造器、构造出的多个复杂型别之间是否有父/子型别关系的用语。
                </div>
                <div class="down-3 right tiny">
                    https://zh.wikipedia.org/wiki/%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98
                </div>
            </section>

            <section>
                <div class="down-3">
                    <h2>通配符</h2>
                </div>

                <div class="down-9">
                    <pre class="java">
                            <code data-trim>
                                    class Fruit{}
                                    class Apple extends Fruit{}
                                    public class GenericsAndCovariance {
                                        public static void main(String[] args){
                                            //一个能放水果以及一切是水果派生类的盘子,啥水果都能放的盘子
                                            //Plate&lt;？ extends Fruit&gt;和Plate&lt;Apple&gt;最大的区别就是：
                                            //Plate&lt;？ extends Fruit&gt;是Plate&lt;Fruit&gt;以及Plate&lt;Apple&gt;的基类。
                                            Plate&lt;? extends Fruit&gt; p=new Plate&lt;Apple&gt;(new Apple());
                                            // a list of any type that's inherited from Fruit
                                            List&lt;? extends Fruit&gt; flist = new ArrayList&lt;Apple&gt;();
                                        }
                                    }
                            </code>              
                        </pre>
                </div>

            </section>
            <section>
                <div class="down-3">
                    <h2>扩展一下</h2>
                </div>

                <div class="down-9">
                    <pre class="java">
                            <code data-trim>
                                    class Food{}
                                    //Lev 2
                                    class Fruit extends Food{}
                                    class Meat extends Food{}
                                    //Lev 3
                                    class Apple extends Fruit{}
                                    class Banana extends Fruit{}
                                    class Pork extends Meat{}
                                    class Beef extends Meat{}
                                    //Lev 4
                                    class RedApple extends Apple{}
                                    class GreenApple extends Apple{}
                            </code>              
                        </pre>
                </div>

            </section>
            <section>

                <div class="down-3">
                    <h2>extends</h2>
                </div>

                <div class="down-1 center">
                    <pre class="java ">
                        <code data-trim>
                                Plate&lt;？ extends Fruit&gt;
                        </code>              
                    </pre>

                    <div class="center down-1">
                        <img src="https://itimetraveler.github.io/gallery/java-genericity/lowerBounds.png" />

                    </div>
            </section>

            <section>
                <div class="down-3">
                    <h2>But</h2>
                </div>

                <div class="down-1">
                    <pre class="java">
                                <code data-trim>
                                        class Fruit{}
                                        class Apple extends Fruit{}
                                        public class GenericsAndCovariance {
                                            public static void main(String[] args){
                                            Plate&lt;? extends Fruit&gt; p=new Plate&lt;Apple&gt;(new Apple());
                                            
                                                //不能存入任何元素
                                                p.set(new Fruit());    //Error
                                                p.set(new Apple());    //Error
                                                //读取出来的东西只能存放在Fruit或它的基类里。
                                                Fruit newFruit1=p.get();
                                                Object newFruit2=p.get();
                                                Apple newFruit3=p.get();    //Error
                                            }
                                        }
                                </code>              
                            </pre>
                </div>
                <div class=" large danger center">
                    <span class="fragment">
                        "A Plate of any type that's inherited from Fruit"的意思不是"a Plate will hold any type of Fruit"
                    </span>
                    <span class="fragment">
                        , but means "some specific type which is not specify" </span>
                </div>

            </section>

            <section>

                <div class="down-3">
                    <h2>super</h2>
                </div>

                <div class="down-1 center">
                    <pre class="java ">
                            <code data-trim>
                                    //表达的就是相反的概念：一个能放水果以及一切是水果基类的盘子。
                                    //Plate&lt;？ super Fruit&gt;是Plate&lt;Fruitt&gt;的基类，但不是Plate&lt;Applet&gt;的基类
                                    Plate&lt;？ super Fruit&gt;
                            </code>              
                        </pre>

                    <div class="center down-1">
                        <img src="https://itimetraveler.github.io/gallery/java-genericity/upperBounds.png" />

                    </div>
            </section>

            <section>
                <div class="down-3">
                    <h2>But</h2>
                </div>
                <div class="down-1">
                    <pre class="java">
                        <code data-trim>
                            class Fruit{}
                            class Apple extends Fruit{}
                            public class GenericsAndCovariance {
                                public static void main(String[] args){
                                Plate&lt;? super Fruit&gt; p=new Plate&lt;Fruit&gt;(new Fruit());
                                    //存入元素正常
                                    p.set(new Fruit());
                                    p.set(new Apple());
                                    //读取出来的东西只能存放在Object类里。
                                    Apple newFruit3=p.get();    //Error
                                    Fruit newFruit1=p.get();    //Error
                                    Object newFruit2=p.get();
                                }
                            }
                        </code>              
                    </pre>
                </div>
            </section>

            <section>
                <div class="down-3">
                    <h2>But</h2>
                </div>
                <div class="down-9">
                    <pre class="java">
                            <code data-trim>
                                    List&lt;?&gt;

                            </code>
                            <code data-trim>
                                    List

                            </code>
                            <code data-trim>
                                    List&lt;Object&gt;
                            </code>              
                        </pre>
                </div>
                <div class=" large danger center">
                    <span class="fragment">
                        区别？ </span>
                </div>
            </section>

            <section>
                <div class="down-3">
                    <h2>Overloading</h2>
                </div>
                <div class="down-9">
                    <pre class="java">
                                <code data-trim>
                                        public class UseList&lt;W,T&gt;{
                                                void f(List&lt;T&gt; v){}
                                                void f(List&lt;W&gt; v){}
                                        }    
                                </code>          
                            </pre>
                </div>
                <div class=" large danger center">
                    <span class="fragment">
                        NO！</span>
                </div>
            </section>

            <section>
                <div class="down-3">
                    <h2>Self-bounded types</h2>
                </div>
                <div class="down-9">
                    <pre class="java">
                                    <code data-trim>
                                            class SelfBounded&lt;T extends SelfBounded&lt;T&gt;&gt;{
                                                    ...
                                            }
                                    </code>          
                                </pre>
                </div>
                <div class=" large center">
                    😢😢😢😢😢😢😢😢😢😢😢😢😢😢😢😢😢😢😢😢😢😢
                </div>
                <div class=" large danger center down-3">
                    <span class="fragment">
                        PP701～</span>
                </div>
            </section>
            <section>
                <div class="down-3">
                    <h2>从简单的开始</h2>
                </div>
                <div class="down-5">
                    <pre class="java">
                        <code data-trim>
                            public class BasicHolder&lt;T&gt; {
                                T element;
                                void set(T arg){this.element = arg;}
                                T get(){return this.element;}
                                void print(){
                                    System.out.println(element.getClass().getSimpleName());
                                }
                            }
                            
                            public class SubType extends BasicHolder&lt;SubType&gt; {
                                public static void main(String[] args){
                                    SubType s1 = new SubType();
                                    SubType s3 = s1.get();
                                    s1.print();
                                    s3.print();
                                }
                            }
                        </code>          
                    </pre>
                </div>
                <div class=" large danger center down-1">
                    <span class="fragment">
                        得到什么？ </span>
                </div>
            </section>

            <section>
                <div class="down-3">
                    <h2>得到什么？</h2>
                </div>
                <div class="down-9">
                    <pre class="java">
                            <code data-trim>
                                public class SubType extends BasicHolder&lt;SubType&gt; {}
                                public class Plate extends BasicHolder&lt;Plate&gt;{}
                                ...
                            </code>          
                        </pre>
                </div>
                <div class=" large danger center down-3">
                    <span class="fragment">
                        P703: ... the generic base class becomes a kind of template for comon functionality for all its
                        derived class</span>
                </div>
                <div class=" large danger center down-3">
                    <span class="fragment">
                        这跟实现一个父类有什么区别？</span>
                </div>
            </section>
            <section>
                <div class="down-3">
                    <h2>跟普通继承关系的区别</h2>
                </div>

                <div class="down-9">
                    ... but this functionality will use the derived type for all of its arguments and return values ...
                </div>
                <div class=" large danger center down-3">
                    <span class="fragment">
                        干得漂亮</span>
                </div>
            </section>

            <section>
                <div class="down-3">
                    <h2>还有一点小问题</h2>
                </div>
                <div class="down-9">
                    <pre class="java">
                            <code data-trim>
                                class Other{}
                                class BasicOther extends BasicHolder&lt;Other&gt;{}
                                
                                public static void main(String[] args){
                                    BasicOther b = new BasicOther(), b2 = new BasicOther();
                                    b.set(new Other());
                                    Other other = b.get();
                                    b.print();// Other
                                }
                            </code>          
                        </pre>
                </div>
                <div class=" large danger center down-3">
                    <span class="fragment">
                        没完全限制</span>
                </div>

            </section>
            <section>
                <div class="down-3">
                    <h2>Self-bounded</h2>
                </div>
                <div class="down-1">
                    <pre class="java">
                            <code data-trim>
                                class SelfBounded&lt;T extends SelfBounded&lt;T&gt;&gt; {
                                    T element;
                                    SelfBounded&lt;T&gt; set(T arg){
                                        element = arg;
                                        return this;
                                    }
                                    T get(){return element;}
                                }
                                
                                class A extends SelfBounded&lt;A&gt; {}
                                class B extends SelfBounded&lt;A&gt; {} //ok 
                                class D;
                                class E extends SelfBounded&lt;D&gt;{} //error
                                
                                public static void main(String[] args){
                                        A a = new A();
                                        a.set(new A());
                                        a.print();
                                
                                        B b = new B(), a2 = new B();
                                        //b.set(b2); //Error
                                        //b.print();
                                }
                            </code>          
                        </pre>
                </div>
                <div class=" large danger center down-3">
                    <span class="fragment">
                        ... forcing the generic to be used as its own bound argument
                    </span>
                </div>

            </section>

            <section>
                <div class="down-3">
                    <h2>高大上一点的说法</h2>
                </div>

                <div class="down-9 center larger">
                    Argument covariance
                </div>
                <div class="down-3 center larger">
                    &
                </div>
                <div class="down-3 center larger">
                    Covariant return types
                </div>
            </section>

            <section>

                <div class="down-3">
                    <h2>Rewrite 葫芦娃 with Generics</h2>
                </div>
                <div class="center down-9">
                    <img
                        src="https://camo.githubusercontent.com/a5cc35d2179c5bf861f6a8eeca25fc5fa3e876a2/687474703a2f2f656e676c6973682e6372692e636e2f6d6d736f757263652f696d616765732f323030392f30362f32342f34363334636172746f6e312e6a7067" />

                </div>
            </section>
        </div>
    </div>
</body>
</head>

</html>